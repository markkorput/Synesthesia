// Generated by CoffeeScript 1.6.3
(function() {
  var ClientOrient, Orients;

  $(document).ready(function() {
    return window.orients = new Orients();
  });

  Orients = (function() {
    function Orients(opts) {
      var _this = this;
      this.options = opts || {};
      this.server = io.connect('/orients');
      this.server.on('welcome', function(data) {
        return console.log("Orients welcomed", data);
      });
      this.server.on('motionData', function(data) {
        return _this.processMotionData(data);
      });
      this.clients = new Backbone.Collection();
      this.initScene();
      this.animate();
      this.clients.on('change:highlighted', function(model, value, obj) {
        if (model.clientOrient) {
          if (value === true) {
            return model.clientOrient.mesh.material.color.setHex(0xBBBBFF);
          } else {
            return model.clientOrient.mesh.material.color.setHex(0xFF0000);
          }
        }
      });
      this.cms = new OrientCms({
        clients: this.clients,
        server: this.server
      });
      this.initGlobalTarget();
    }

    Orients.prototype.initScene = function() {
      this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
      this.renderer = new THREE.WebGLRenderer();
      this._resize();
      $(window).resize(this._resize);
      document.body.appendChild(this.renderer.domElement);
      this.scene = new THREE.Scene();
      this.camera.position.set(0, 300, 0);
      this.camera.lookAt(this.scene.position);
      this.camera.rotation.z = Math.PI;
      this.light = new THREE.PointLight(0xFFFFFF);
      this.light.position.copy(this.camera.position);
      this.light.position.x += 3;
      this.light.position.y += 3;
      return this.scene.add(this.light);
    };

    Orients.prototype.initGlobalTarget = function() {
      var geometry, material,
        _this = this;
      this.globalTargetRotator = new THREE.Object3D();
      this.globalTargetRotator.position.set(0, 0, 0);
      geometry = new THREE.SphereGeometry(10);
      material = new THREE.MeshLambertMaterial({
        color: 0x00FF00
      });
      this.globalTargetMesh = new THREE.Mesh(geometry, material);
      this.globalTargetMesh.position.set(0, 0, 80);
      this.globalTargetRotator.add(this.globalTargetMesh);
      this.scene.add(this.globalTargetRotator);
      return this.cms.globalItemView.model.on('change:targetOrientationValue', function(model, value, obj) {
        return _this.globalTargetRotator.rotation.y = value / 180 * Math.PI;
      });
    };

    Orients.prototype.updateGlobalTarget = function() {
      if (!this.cms || !this.cms.targetControlView || !this.cms.targetControlView.model) {

      }
    };

    Orients.prototype._resize = function(event) {
      if (this.camera) {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
      }
      if (this.renderer) {
        return this.renderer.setSize(window.innerWidth, window.innerHeight * 0.7);
      }
    };

    Orients.prototype.animate = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.animate();
      });
      return this.draw();
    };

    Orients.prototype.draw = function() {
      return this.renderer.render(this.scene, this.camera);
    };

    Orients.prototype.processMotionData = function(data) {
      var clientOrient, model, pos, vec3;
      vec3 = new THREE.Vector3(data.beta / 180 * Math.PI, data.alpha / 180 * Math.PI, -data.gamma / 180 * Math.PI);
      if (model = this.clients.get(data.cid)) {
        return model.set({
          orientation: vec3
        });
      } else {
        pos = new THREE.Vector3(-50 + Math.random() * 100, -50 + Math.random() * 100, 0);
        model = new Backbone.Model({
          id: data.cid,
          orientation: vec3,
          position: pos
        });
        this.clients.add(model);
        clientOrient = new ClientOrient({
          model: model
        });
        model.clientOrient = clientOrient;
        return this.scene.add(clientOrient.mesh);
      }
    };

    return Orients;

  })();

  ClientOrient = (function() {
    function ClientOrient(opts) {
      var geometry, material, subgeometry;
      this.options = opts || {};
      geometry = new THREE.CubeGeometry(10, 2, 20);
      material = new THREE.MeshLambertMaterial({
        color: 0xFF0000
      });
      this.mesh = new THREE.Mesh(geometry, material);
      this.model = opts.model;
      subgeometry = new THREE.CubeGeometry(2, 2, 10);
      this.submesh = new THREE.Mesh(subgeometry, material);
      this.submesh.position.set(0, 0, 10);
      this.mesh.add(this.submesh);
      if (this.model) {
        this.model.on('change:orientation', this.update, this);
        this.update();
      }
    }

    ClientOrient.prototype.update = function() {
      var value;
      if (this.model) {
        if (value = this.model.get('orientation')) {
          this.mesh.rotation.fromArray(value.toArray());
        }
        if (value = this.model.get('position')) {
          return this.mesh.position.fromArray(value.toArray());
        }
      }
    };

    return ClientOrient;

  })();

}).call(this);
